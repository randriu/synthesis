
dtmc


// agent1 can go in this direction
formula u1 = ya1<7 & !(xa1=3 & ya1=2) & !(ya1=5 & xa1>3);
formula r1 = xa1<7 & !(xa1=4 & ya1<4) & !(xa1=2 & (ya1>2 & ya1<7));
formula d1 = ya1>0 & !(ya1=2 & xa1<2) & !(ya1=7 & xa1>2) & !(ya1=4 & xa1=5);
formula l1 = xa1>0 & !(xa1=2 & ya1<2) & !(xa1=6 & ya1<4) & !(xa1=4 & (ya1>2 & ya1<6));

// updates of coordinates (if possible)
formula y1u = u1 ? (ya1+1) : ya1;
formula x1r = r1 ? (xa1+1) : xa1;
formula y1d = d1 ? (ya1-1) : ya1;
formula x1l = l1 ? (xa1-1) : xa1;


// agent2 can go in this direction
formula u2 = ya2<7 & !(xa2=3 & ya2=2) & !(ya2=5 & xa2>3);
formula r2 = xa2<7 & !(xa2=4 & ya2<4) & !(xa2=2 & (ya2>2 & ya2<7));
formula d2 = ya2>0 & !(ya2=2 & xa2<2) & !(ya2=7 & xa2>2) & !(ya2=4 & xa2=5);
formula l2 = xa2>0 & !(xa2=2 & ya2<2) & !(xa2=6 & ya2<4) & !(xa2=4 & (ya2>2 & ya2<6));

// updates of coordinates (if possible)
formula y2u = u2 ? (ya2+1) : ya2;
formula x2r = r2 ? (xa2+1) : xa2;
formula y2d = d2 ? (ya2-1) : ya2;
formula x2l = l2 ? (xa2-1) : xa2;


const double sl=0.1;

//obs: empty, wall, other, small, large
formula empty1 = 

// agent 1 holes
hole int M1_0_1 in {0,1};
hole int M1_0_0 in {0,1};
hole int M1_1_1 in {0,1};
hole int M1_1_0 in {0,1};
hole int P1_0_1 in {1,2,3,4};
hole int P1_0_0 in {1,2,3,4};
hole int P1_1_1 in {1,2,3,4};
hole int P1_1_0 in {1,2,3,4};

// agent 2 holes
hole int M2_0_1 in {0,1};
hole int M2_0_0 in {0,1};
hole int M2_1_1 in {0,1};
hole int M2_1_0 in {0,1};
hole int P2_0_1 in {1,2,3,4};
hole int P2_0_0 in {1,2,3,4};
hole int P2_1_1 in {1,2,3,4};
hole int P2_1_0 in {1,2,3,4};

module strategy1
	mem : [0..1] init 0;

	[act]  mem=0 & r1  -> (mem'=M1_0_1);
	[act]  mem=0 & !r1 -> (mem'=M1_0_0);
	[act]  mem=1 & r1  -> (mem'=M1_1_1);
	[act]  mem=1 & !r1 -> (mem'=M1_1_0);
endmodule

module strategy2
	mem2 : [0..1] init 0;

	[act]  mem2=0 & l2  -> (mem2'=M2_0_1);
	[act]  mem2=0 & !l2 -> (mem2'=M2_0_0);
	[act]  mem2=1 & l2  -> (mem2'=M2_1_1);
	[act]  mem2=1 & !l2 -> (mem2'=M2_1_0);
endmodule

module grid

	x1 : [0..2] init 0; // agent1 x coordinate
    d1: [0..3] init 1; // directions: 0 - up, 1 - right, 2 - down, 3 - left
    x2 : [1..3] init 3; // agent2 x coordinate
    d2: [0..3] init 3; // directions: 0 - up, 1 - right, 2 - down, 3 - left

    a1: [0..3] init 0; // actions: turnLeft turnRight moveForward stay
    a2: [0..3] init 0; // actions: turnLeft turnRight moveForward stay

	[choose] 



	[act]  x1=0 -> 1-sl: (ya1'=y1u) + sl: true;
	
endmodule

module clk
    c : bool init true;
    [choose] c -> 1: (c'=false);
    [act] !c -> 1: (c'=true);
endmodule
	
const double discount = 0.99;

module df
    sink : bool init false;
    [act] !sink -> discount: true + 1-discount: (sink'=true);
endmodule

// reward
rewards "moves"
	!sink & !c: -1;
endrewards

// target
label "goal" = sink=true;

